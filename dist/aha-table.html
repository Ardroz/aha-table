<!--
//http://webcomponents.github.io/articles/web-components-best-practices/
-->
<!--
/**
 * @module aha-table
 *
 *
 * Searchable Sortable Editable Paginatable Data Table
 *
 * aha-table is an data table/grid, it cousumes a modal data
 * and modal meta to show a table that can search, sort, edit
 * in place and pagiation.
 * 
 * Double click to edit.
 * 
 * Examples:
 *
 *     <aha-table></aha-table>
 *
 *     <aha-table 
 *       data='[{"title": "bob", "age": 16}, {"title": "mary", "age": 17}]' 
 *       meta='[{"name": "title", label: "Title", sortable: true, searchable: true, type: "text", editable: true, required: true},
 *              {"name": "age", label: "Age", sortable: true, searchable: true, type: "text", editable: true, required: true}]'
 *       perpage='20'>
 *     </aha-table>
 *
 * @class aha-table
 * @author Louis Liu<louis.wenchao.liu@gmail.com>
 *
 */
-->

<link rel="import" href="../../polymer/polymer.html">

<polymer-element name="aha-table" attributes="data meta perpage selectable">
	<template>
		<style>
			/* styles for the custom element itself - lowest specificity */
			aha-table { 
				display: block;
			}
			.rows:hover, .selected {
				background-color: #f3f3f3;
			}
			.sortable .label, .hint {
				cursor: pointer;
			}
			.sortable:hover {
				text-decoration: underline;
			}
			.sorting.arrow-up {
				width: 0; 
				height: 0; 
				border-left: 5px solid transparent;
				border-right: 5px solid transparent;
				border-bottom: 5px solid black;
			}
			.sorting.arrow-down {
				width: 0; 
				height: 0; 
				border-left: 5px solid transparent;
				border-right: 5px solid transparent;
				border-top: 5px solid black;
			}
			.pagination {
				margin: 10px;
				text-align: center;
				line-height: 20px;
			}
			.pagination .active button {
				background-color: #ccc;
			}
			.pagination .disabled button {
				color: #ccc;
			}
			.pagination button {
				background-color: #fff;
				border: 1px solid #eeeeee;
				min-width: 40px;
				line-height: 20px;
				padding: 4px 12px;
				text-decoration: none;
				cursor: pointer;
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			.pagination input {
				background-color: #fff;
				border: 1px solid #eeeeee;
				width: 40px;
				line-height: 20px;
				padding: 4px 12px;
			}
			.hide {
				display: none;
			}
		</style>
		<table>
			<thead>
				<tr>
					<th>
						<input type="checkbox" 
							on-change="{{ selectall }}" 
							title="Select All"/>
					</th>
					<th template 
						repeat="{{ column in meta }}"
						class="{{ column.sortable ? 'sortable' : ''}} aha-{{column.name}}-th">
						<span class="
							{{ sortedColumn == column.name ? 'sorting ' : ''}}
							{{ descending ? 'arrow-down' : 'arrow-up'}}">
						</span>
						<span 
							class="label" 
							on-click="{{ sort }}">
							{{ column.label ? column.label : column.name | capitalize }}
						</span>
						<sup 
							class="{{ column.hint ? 'hint' : 'hide' }}" 
							title="{{ column.hint }}">i</sup>
						<div class="{{ column.searchable ? 'searchable' : 'hide'">
							<select 
								on-change="{{ search }}" 
								class="{{ 'select' === column.type ? '' : 'hide' }}">
									<option template 
										repeat="{{ option in column.options }}"
										value="{{ option.value }}">
										{{ option.label }}
									</option>
							</select>
							<input type="checkbox" 
								on-change="{{ search }}" 
								class="{{ 'checkbox' === column.type ? '' : 'hide' }}"/>
							<input type="text" 
								on-keyup="{{ search }}" 
								placeholder="filter" 
								class="{{ 'checkbox' !== column.type && 'select' !== column.type ? '' : 'hide' }}"/>
						</div>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr template
					repeat="{{ row in data | _sort(sortedColumn, descending) }}" 
					class="rows
						{{ row._hidden || row._filtered ? 'hide' : ''}}
						{{ row._selected ? 'selected' : '' }}
					">
					<td title="Click to select">
						<input type="checkbox" 
							on-change="{{ select }}" 
							checked?="{{ row._selected }}"/>
					</td>
					<td template 
						repeat="{{ column in meta }}" 
						on-dblclick="{{ edit }}" 
						on-click="{{select}}" 
						title="Double click to edit" 
						class="aha-{{column.name}}-td">
						<div class="{{ column.name === row._editing_column ? '' : 'hide'}}">
							<select 
								class="{{ 'select' === column.type ? '' : 'hide'}}"
								on-change="{{ save }}" 
								on-blur="{{ save }}">
								<option template
									repeat="{{ option in column.options }}"
									value="{{ option.value }}" 
									selected?="{{ row[column.name] == option.value }}">
									{{ option.label }}
								</option>
							</select>
							<input type="text" 
								class="{{ 'text' === column.type ? '' : 'hide'}}"
								on-blur="{{ save }}" 
								value="{{ row[column.name] }}"/>
							<input type="date" 
								class="{{ 'date' === column.type ? '' : 'hide'}}"
								on-blur="{{ save }}" 
								value="{{ row[column.name] }}"/>
							<textarea 
								class="{{ 'textarea' === column.type ? '' : 'hide'}}"
								on-blur="{{ save }}">
								{{ row[column.name] }}
							</textarea>
							<input type="checkbox" 
								class="{{ 'checkbox' === column.type ? '' : 'hide'}}"
								on-change="{{ save }}" 
								checked?="{{ row[column.name] }}" />
						</div>
						<div class="{{ column.name === row._editing_column ? 'hide' : ''}}">
							{{ row[column.name] ? row[column.name] : '' }}
						</div>
					</td>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<td colspan="{{meta.length+1}}" class="pagination">
						<table>
							<tr>
								<td class='{{currentpage === 0 ? "disabled" : ""}} '>
									<button on-click="{{firstPage}}">{{first}}</button>
								</td>
								<td class='{{currentpage === 0 ? "disabled" : ""}}'>
									<button on-click="{{prevPage}}">{{previous}}</button>
								</td>
								<td template
									repeat="{{ n in currentRange }}" 
									class="{{n == currentpage ? 'active' : ''}}" 
									on-click="{{setPage}}">
									<button>{{n+1}}</button>
								</td>
								<td class='{{pageCount <= 0 || currentpage === pageCount? "disabled" : ""}}'>
									<button on-click="{{nextPage}}">{{next}}</button>
								</td>
								<td class='{{pageCount <= 0 || currentpage === pageCount? "disabled" : ""}}'>
									<button on-click="{{lastPage}}">{{last}}</button>
								</td>
								<td>
									Page Size: <input value="{{perpage}}"/>
									{{ firstItemIndex }} - {{ lastItemIndex }} / {{ itemCount }}
								</td>
							</tr>
						</table>
					</td>
				</tr>
			</tfoot>
		</table>
	</template>
	<script>
	Polymer('aha-table', {
		/**
		 * data: instance of the model data
		 * @type {Array}
		 */
		data: [],
		/**
		 * meta: instance of the model meta
		 * @type {Object}
		 */
		meta: [],
		/**
		 * modified: all created or modified row will be referenced here.
		 * it's hard to determine if it's created or modified after multiple
		 * operations, because the element doesn't assume there's an id column,
		 * so you need to determine if by yourself, like check
		 * if the id exists if your model has an id column.
		 * @type {Array}
		 */
		modified: [],
		/**
		 * deleted: all deleted row will be moved here.
		 * @type {Array}
		 */
		deleted: [],
		/**
		 * selected: all selected row will be referenced here.
		 * @type {Array}
		 */
		selected: [],
		/**
		 * selectable: if table row is selectable
		 * @type {Boolean}
		 */
		selectable: true,
		/**
		 * sortedColumn: sorted column name
		 * @type {String}
		 */
		sortedColumn: null,
		/**
		 * descending: current sorting order
		 * @type {Boolean}
		 */
		descending: false,
		/**
		 * perpage: the number of items to show per page
		 * @type {Number}
		 */
		perpage: 10,
		/**
		 * currentpage: the current active page in view
		 * @type {Number}
		 */
		currentpage: 0,
		/**
		 * currentRange: the range of pages (e.g 1, 2, 3, 4, 5) to display
		 * @type {Array}
		 */
		currentRange: [],
		/**
		 * pageCount: the number of paginated pages
		 * @type {Number}
		 */
		pageCount: 0,
		/**
		 * itemCount: the number of visible items
		 * @type {Number}
		 */
		itemCount: 0,
		/**
		 * firstItemIndex: the index number of first item in the page, start from 1
		 * @type {Number}
		 */
		firstItemIndex: 0,
		/**
		 * lastItemIndex: the index number of last item in the page, start from 1
		 * @type {Number}
		 */
		lastItemIndex:  0,
		/**
		 * rangeSize: the total size of the paginated range of items
		 * @type {Number}
		 */
		rangeSize: 5,
		/**
		 * previous: label for the Previous button
		 * @type {String}
		 */
		previous: "<",
		/**
		 * next: label for the Next button
		 * @type {String}
		 */
		next: ">",
		/**
		 * next: label for the First page button
		 * @type {String}
		 */
		first: "<<",
		/**
		 * next: label for the Last page button
		 * @type {String}
		 */
		last: ">>",

		//=============
		//internal methods
		dataChanged: function() {
			this.refreshPagination();
			if (this.meta.length === 0)  {
				this.meta = [];
				for (var prop in this.data[0]) {
					if (prop.indexOf('_') !== 0) {//skip internal field
						this.meta.push({
							name: prop,
							label: prop.charAt(0).toUpperCase() + prop.slice(1), 
							type: true === this.data[0][prop] || false === this.data[0][prop] ? "checkbox" : "text", 
							sortable: true, 
							searchable: true, 
							editable: true, 
							required: false
						});
					}
				}
			}
		},
		capitalize: function(value) {
			if (!value instanceof String || value.length === 0) 
				return value;
			return value.charAt(0).toUpperCase() + value.slice(1);
		},
		edit: function(e) {
			if(e.target.templateInstance.model.row){
				e.target.templateInstance.model.row._editing_column = e.target.templateInstance.model.column.name;
			}
		},
		save: function(e) {
			var model = e.target.templateInstance.model;
			if(model.row){
				if ("CHECKBOX" === e.target.type.toUpperCase()) {
					model.row[model.column.name] = e.target.checked;
				} else if ("SELECT" === e.target.tagName.toUpperCase()) {
					model.row[model.column.name] = e.target.value;
				}
				if (this.modified.indexOf(model.row) === -1) {
					this.modified.push(model.row);
				}
				model.row._editing_column = null;
			}
		},
		sort: function(e, p) {
			if(e.target.templateInstance.model.column){
				var sortingColumn = e.target.templateInstance.model.column.name;
				if (sortingColumn == this.sortedColumn){
					this.descending = !this.descending;
				} else {
					this.sortedColumn = sortingColumn;
				}
			}
		},
		search: function(e, p) {
			if(e.target.templateInstance.model.column){
				var searchedColumn = e.target.templateInstance.model.column.name;
				for (var i = this.data.length - 1; i >= 0; i--) {
					if (this.data[i]._not_matched_columns === undefined) {
						this.data[i]._not_matched_columns = [];
					}

					if ("CHECKBOX" === e.target.type.toUpperCase()) {
						this.data[i]._filtered = e.target.checked && !this.data[i][searchedColumn];
						continue;
					}

					if (e.target.value === ""
						|| this.data[i][searchedColumn]
						&& this.data[i][searchedColumn].toString().slice(0, e.target.value.length).toLowerCase() == e.target.value.toString().toLowerCase()) {
						var _not_matched_index = this.data[i]._not_matched_columns.indexOf(searchedColumn);
						if (_not_matched_index > -1) {
							this.data[i]._not_matched_columns.splice(_not_matched_index, 1);
						}
						if (this.data[i]._not_matched_columns.length === 0) {
							this.data[i]._filtered = false;
						} else {
							this.data[i]._filtered = true;
						}
					} else {
						this.data[i]._filtered = true;
						if (this.data[i]._not_matched_columns.indexOf(searchedColumn) === -1) {
							this.data[i]._not_matched_columns.push(searchedColumn);
						}
					}
				};

				this.currentpage = 0;
				this.refreshPagination();
			}
		},
		_sort: function(array, key, desc) {
			if (!array) return;

			return array.sort(function(a, b) {
				var x = a[key], y = b[key];

				if (typeof x === 'undefined' || typeof y === 'undefined') {
					//sort undefined after
					if (typeof x === 'undefined'){
						return !desc;
					}else{
						return desc;
					}
				} else {
					if (typeof x === "string" && typeof y === "string"){
						x = x.toLowerCase();
						y = y.toLowerCase();
					}
					if (desc){
						return ((x < y) ? 1 : ((x > y) ? -1 : 0));
					} else {
						return ((x < y) ? -1 : ((x > y) ? 1 : 0));
					}
				}
			});
		},

		//==================
		//pagination
		firstPage: function() {
			this.currentpage = 0;
		},
		prevPage: function() {
			if ( this.currentpage > 0 ) {
				this.currentpage--;
			}
		},
		nextPage: function() {
			if ( this.currentpage < this.getPageCount() ) {
				this.currentpage++;
			}
		},
		lastPage: function() {
			this.currentpage = this.getPageCount();
		},
		getItemCount: function() {
			var count = 0;
			for (var i = this.data.length - 1; i >= 0; i--) {
				if (!this.data[i]._filtered) {
					count++;
				}
			};
			return count;
		},
		getPageCount: function() {
			return Math.ceil( this.getItemCount() / this.perpage ) - 1;
		},
		setPage: function(e,d,t) {
			this.currentpage = parseInt( t.dataset.item, 10 );
		},
		currentpageChanged: function(){
			this.filterPage();
			this.currentRange = this.range();
			this.firstItemIndex = this.currentpage * this.perpage + 1;
			if (this.currentpage === this.pageCount) {
				this.lastItemIndex = this.itemCount;
			} else {
				this.lastItemIndex = (this.currentpage + 1)* this.perpage;
			}
		},
		perpageChanged: function(){
			this.currentpage = 0;
			this.refreshPagination();
		},
		range: function() {
			var paginations = [];
			var start = this.currentpage;

			if ( start > this.getPageCount() - this.rangeSize ) {
				start = this.getPageCount() - this.rangeSize + 1;
			}

			for ( var i = start; i < start + this.rangeSize; i++ ) {
				if (i >= 0) {
					paginations.push(i);
				}
			}
			return paginations;
		},
		filterPage: function() {
			var from = this.currentpage * this.perpage;
			var to   = from + this.perpage;
			var count = 0;
			for (var i = 0; i < this.data.length; i++) {
				if (!this.data[i]._filtered) {
					count++;
				}
				if (count <= from || count > to) {
					this.data[i]._hidden = true;
				} else {
					this.data[i]._hidden = false;
				}
			};
		},
		refreshPagination: function() {
			// Update current range to account for items per page, range.
			this.currentRange = this.range();

			// Cache the total page count and item count
			this.itemCount = this.getItemCount();
			this.pageCount = this.getPageCount();
			this.firstItemIndex = this.currentpage * this.perpage + 1;
			if (this.currentpage === this.pageCount) {
				this.lastItemIndex = this.itemCount;
			} else {
				this.lastItemIndex = (this.currentpage + 1)* this.perpage;
			}

			// Update model bound to UI with filtered range
			this.filterPage();
		},


		//=======================//
		//data manipulation//
		select: function(e,p){
			var row = e.target.templateInstance.model.row;
			var index = this.selected.indexOf(row);
			if (index > -1) {
				if(row._selected){
					this.selected.splice(index, 1);
					row._selected = false;
				}
			} else {
				if(!row._selected){
					this.selected.push(row);
					row._selected = true;
				}
			}
			e.preventDefault();
		},
		selectall: function(e,p){
			if(e.target.checked){
				for(var i=0;i<this.data.length;i++){
					if (!this.data[i]._filtered && !this.data[i]._hidden) {
						if(this.selected.indexOf(this.data[i])==-1) {
							this.selected.push(this.data[i]);
						}
						this.data[i]._selected = true;
					}
				}
			}else{
				this.selected = [];
				for(var i=0;i<this.data.length;i++){
					this.data[i]._selected = false;
				}
			}
		},
		create: function(obj) {
			var _new = obj instanceof Object ? obj : {};
			var _default = {_editing_column: this.meta[0].name};
			for (var i = this.meta.length - 1; i >= 0; i--) {
				if (this.meta[i].default && obj[this.meta[i].name] === undefined) {
					_new[this.meta[i].name] = this.meta[i].default;
				}
			};
			this.data.splice(0,0,_new);
			this.modified.push(_new);
		},
		copy: function(obj) {
			if (obj) {
				var _new = JSON.parse(JSON.stringify(obj));
				if (_new.id) {
					delete _new.id
				}
				if (_new._selected) {
					_new._selected = false;
				}
				_new._editing_column = this.meta[0].name;
				this.data.splice(0,0,_new);
				this.modified.push(_new);
			}
		},
		copySelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.copy(this.selected[i]);
			};
			this.clearSelected();
		},
		remove: function(obj) {
			var found_index = this.data.indexOf(obj);
			if (found_index !== -1) {
				this.data.splice(found_index,1);
				this.deleted.push(obj);
			}
		},
		removeSelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.remove(this.selected[i]);
			}
			this.clearSelected();
		},
		clearSelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.selected[i]._selected = false;
			}
			this.selected.length = 0;
		},
		clearModified: function() {
			this.modified.length = 0;
		},
		clearDeleted: function() {
			this.deleted.length = 0;
		}
	});
	</script>
</polymer-element>
