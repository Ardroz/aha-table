<!--
//http://webcomponents.github.io/articles/web-components-best-practices/
-->
<!--
/**
 * @module aha-table
 *
 *
 * Searchable Sortable Editable Paginatable Data Table
 *
 * aha-table is an data table/grid, it cousumes a modal data
 * and modal meta to show a table that can search, sort, edit
 * in place and pagiation.
 * 
 * Double click to edit.
 * 
 * Examples:
 *
 *     <aha-table></aha-table>
 *
 *     <aha-table 
 *       data='[{"title": "bob", "age": 16}, {"title": "mary", "age": 17}]' 
 *       meta='[{"name": "title", label: "Title", sortable: true, searchable: true, type: "text", editable: true, required: true},
 *              {"name": "age", label: "Age", sortable: true, searchable: true, type: "text", editable: true, required: true}]'
 *       perpage='20'>
 *     </aha-table>
 *
 * @class aha-table
 * @author Louis Liu<louis.wenchao.liu@gmail.com>
 *
 */
-->

<link rel="import" href="../../polymer/polymer.html">

<polymer-element name="aha-table" attributes="data meta perpage selectable">
	<template>
		<style>
			/* styles for the custom element itself - lowest specificity */
			aha-table { 
				display: block;
			}
			aha-table tbody tr:hover, .selected {
				background-color: #f3f3f3;
				color: #1B8CCD;
			}
			.sortable {
				text-align: center;
				cursor: pointer;
			}
			.sortable:hover {
				text-decoration: underline;
			}
			.arrow-up {
				width: 0; 
				height: 0; 
				border-left: 5px solid transparent;
				border-right: 5px solid transparent;
				border-bottom: 5px solid black;
			}
			.arrow-down {
				width: 0; 
				height: 0; 
				border-left: 5px solid transparent;
				border-right: 5px solid transparent;
				border-top: 5px solid black;
			}
			.pagination {
				margin: 30px 0 10px 0;
				text-align: center;
			}
			.pagination ul {
				display: inline-block;
				margin: 0;
				padding: 0;
			}
			.pagination li {
				display: inline;
				line-height: 20px;
			}
			.pagination li.active button {
				background-color: #ccc;
			}
			.pagination li.disabled button {
				color: #ccc;
			}
			.pagination li:first-child button {
				-webkit-border-radius: 5px 0 0 5px;
				-moz-border-radius: 5px 0 0 5px;
				border-radius: 5px 0 0 5px;
			}
			.pagination li:last-child button {
				-webkit-border-radius: 0 5px 5px 0;
				-moz-border-radius: 0 5px 5px 0;
				border-radius: 0 5px 5px 0;
			}
			.pagination li button {
				background-color: #fff;
				border: 1px solid #eeeeee;
				float: left;
				min-width: 40px;
				line-height: 20px;
				padding: 4px 12px;
				text-decoration: none;
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			.pagination li input {
				background-color: #fff;
				border: 1px solid #eeeeee;
				float: left;
				width: 30px;
				line-height: 20px;
				padding: 4px 12px;
			}
			.pagination .summary input {
				width: 40px;
			}
		</style>
		<table>
			<thead>
				<tr>
					<th>
						<input type="checkbox" on-change="{{ selectall }}" title="Select All"/>
					</th>
					<template repeat="{{ column in meta }}">
						<template if="{{ column.sortable }}">
							<th class="sortable aha-{{column.name}}-sortable-th" on-click="{{ sort }}" title="{{ column.hint }}">
								<template if="{{ sortedColumn == column.name && descending }}">
									<span class="arrow-down"></span>
								</template>
								<template if="{{ sortedColumn == column.name && !descending }}">
									<span class="arrow-up"></span>
								</template>
								{{ column.label ? column.label : column.name | capitalize }}
							</th>
						</template>
						<template if="{{ !column.sortable }}">
							<th title?={{ column.hint }}>{{ column.label ? column.label : column.name | capitalize }}</th>
						</template>
					</template>
				</tr>
				<tr>
					<th></th>
					<template repeat="{{ column in meta }}">
						<th class="searchable aha-{{column.name}}-searchable-th">
							<template if="{{ column.searchable }}">
								<template if="{{ 'select' === column.type }}">
									<select on-change="{{ search }}">
										<template repeat="{{ option in column.options }}">
											<option value="{{ option.value }}">{{ option.label }}</option>
										</template>
									</select>
								</template>
								<template if="{{ 'checkbox' === column.type }}">
									<input type="checkbox" on-change="{{ search }}"/>
								</template>
								<template if="{{ 'checkbox' !== column.type && 'select' !== column.type }}">
									<input type="text" on-keyup="{{ search }}" placeholder="filter"/>
								</template>
							</template>
						</th>
					</template>
				</tr>
			</thead>
			<tbody>
				<template repeat="{{ row in data | _sort(sortedColumn, descending) }}">
					<template if="{{ !row._hidden && !row._filtered }}">
						<tr class="{{ row._selected ? 'selected' : '' }}">
							<td title="Click to select">
								<template if="{{ row._selected }}">
									<input type="checkbox" on-change="{{ select }}" checked/>
								</template>
								<template if="{{ !row._selected }}">
									<input type="checkbox" on-change="{{ select }}"/>
								</template>
							</td>
							<template repeat="{{ column in meta }}">
								<td on-dblclick="{{ edit }}" on-click="{{select}}" title="Double click to edit" class="aha-{{column.name}}-td">
									<template if="{{ column.name == row._editing_column }}">
										<template if="{{ 'select' === column.type }}">
											<select on-change="{{ save }}" on-blur="{{ save }}">
												<template repeat="{{ option in column.options }}">
													<template if="{{ row[column.name] == option.value }}">
														<option value="{{ option.value }}" selected>
															{{ option.label }}
														</option>
													</template>
													<template if="{{ row[column.name] !== option.value }}">
														<option value="{{ option.value }}">
															{{ option.label }}
														</option>
													</template>
												</template>
											</select>
										</template>
										<template if="{{ 'text' === column.type }}">
											<input type="text" on-blur="{{ save }}" value="{{ row[column.name] }}"/>
										</template>
										<template if="{{ 'date' === column.type }}">
											<input type="date" on-blur="{{ save }}" value="{{ row[column.name] }}"/>
										</template>
										<template if="{{ 'textarea' === column.type }}">
											<textarea on-blur="{{ save }}">{{ row[column.name] }}</textarea>
										</template>
										<template if="{{ 'checkbox' === column.type }}">
											<input type="checkbox" on-change="{{ save }}" checked?="{{ row[column.name] }}" />
										</template>
									</template>
									<template if="{{ column.name !== row._editing_column }}">
										{{ row[column.name] ? row[column.name] : '' }}
									</template>
								</td>
							</template>
						</tr>
					</template>
				</template>
			</tbody>
			<tfoot>
				<tr>
					<td colspan={{meta.length+1}}>
						<div class="pagination">
							<ul>
								<li class='{{currentpage === 0 ? "disabled" : ""}}'>
									<button on-click="{{firstPage}}">{{first}}</button>
								</li>
								<li class='{{currentpage === 0 ? "disabled" : ""}}'>
									<button on-click="{{prevPage}}">{{previous}}</button>
								</li>

								<template repeat="{{n in currentRange}}">
									<li class="{{n == currentpage ? 'active' : ''}}" data-item="{{n}}" on-click="{{setPage}}">
										<button>{{n+1}}</button>
									</li>
								</template>

								<li class='{{pageCount <= 0 || currentpage === pageCount? "disabled" : ""}}'>
									<button on-click="{{nextPage}}">{{next}}</button>
								</li>
								<li class='{{pageCount <= 0 || currentpage === pageCount? "disabled" : ""}}'>
									<button on-click="{{lastPage}}">{{last}}</button>
								</li>
							</ul>
							<div class="summary">
								Page Size: <input value="{{perpage}}"/>
								Viewing {{ firstItemIndex }} - {{ lastItemIndex }} of {{ itemCount }}
							</div>
						</div>
					</td>
				</tr>
			</tfoot>
		</table>
	</template>
	<script>
	Polymer('aha-table', {
		/**
		 * data: instance of the model data
		 * @type {Array}
		 */
		data: [],
		/**
		 * meta: instance of the model meta
		 * @type {Object}
		 */
		meta: [],
		/**
		 * modified: all created or modified row will be referenced here.
		 * it's hard to determine if it's created or modified after multiple
		 * operations, because the element doesn't assume there's an id column,
		 * so you need to determine if by yourself, like check
		 * if the id exists if your model has an id column.
		 * @type {Array}
		 */
		modified: [],
		/**
		 * deleted: all deleted row will be moved here.
		 * @type {Array}
		 */
		deleted: [],
		/**
		 * selected: all selected row will be referenced here.
		 * @type {Array}
		 */
		selected: [],
		/**
		 * selectable: if table row is selectable
		 * @type {Boolean}
		 */
		selectable: true,
		/**
		 * sortedColumn: sorted column name
		 * @type {String}
		 */
		sortedColumn: null,
		/**
		 * descending: current sorting order
		 * @type {Boolean}
		 */
		descending: false,
		/**
		 * perpage: the number of items to show per page
		 * @type {Number}
		 */
		perpage: 10,
		/**
		 * currentpage: the current active page in view
		 * @type {Number}
		 */
		currentpage: 0,
		/**
		 * currentRange: the range of pages (e.g 1, 2, 3, 4, 5) to display
		 * @type {Array}
		 */
		currentRange: [],
		/**
		 * pageCount: the number of paginated pages
		 * @type {Number}
		 */
		pageCount: 0,
		/**
		 * itemCount: the number of visible items
		 * @type {Number}
		 */
		itemCount: 0,
		/**
		 * firstItemIndex: the index number of first item in the page, start from 1
		 * @type {Number}
		 */
		firstItemIndex: 0,
		/**
		 * lastItemIndex: the index number of last item in the page, start from 1
		 * @type {Number}
		 */
		lastItemIndex:  0,
		/**
		 * rangeSize: the total size of the paginated range of items
		 * @type {Number}
		 */
		rangeSize: 5,
		/**
		 * previous: label for the Previous button
		 * @type {String}
		 */
		previous: "Previous <",
		/**
		 * next: label for the Next button
		 * @type {String}
		 */
		next: "> Next",
		/**
		 * next: label for the First page button
		 * @type {String}
		 */
		first: "First <<",
		/**
		 * next: label for the Last page button
		 * @type {String}
		 */
		last: ">> Last",

		//=============
		//internal methods
		dataChanged: function() {
			this.refreshPagination();
			if (this.meta.length === 0)  {
				this.meta = [];
				for (var prop in this.data[0]) {
					if (prop.indexOf('_') !== 0) {//skip internal field
						this.meta.push({
							name: prop,
							label: prop.charAt(0).toUpperCase() + prop.slice(1), 
							type: true === this.data[0][prop] || false === this.data[0][prop] ? "checkbox" : "text", 
							sortable: true, 
							searchable: true, 
							editable: true, 
							required: false
						});
					}
				}
			}
		},
		capitalize: function(value) {
			if (!value instanceof String || value.length === 0) 
				return value;
			return value.charAt(0).toUpperCase() + value.slice(1);
		},
		edit: function(e) {
			if(e.target.templateInstance.model.row){
				e.target.templateInstance.model.row._editing_column = e.target.templateInstance.model.column.name;
			}
		},
		save: function(e) {
			var model = e.target.templateInstance.model;
			if(model.row){
				if ("CHECKBOX" === e.target.type.toUpperCase()) {
					model.row[model.column.name] = e.target.checked;
				} else if ("SELECT" === e.target.tagName.toUpperCase()) {
					model.row[model.column.name] = e.target.value;
				}
				if (this.modified.indexOf(model.row) === -1) {
					this.modified.push(model.row);
				}
				model.row._editing_column = null;
			}
		},
		sort: function(e, p) {
			if(e.target.templateInstance.model.column){
				var sortingColumn = e.target.templateInstance.model.column.name;
				if (sortingColumn == this.sortedColumn){
					this.descending = !this.descending;
				} else {
					this.sortedColumn = sortingColumn;
				}
			}
		},
		search: function(e, p) {
			if(e.target.templateInstance.model.column){
				var searchedColumn = e.target.templateInstance.model.column.name;
				for (var i = this.data.length - 1; i >= 0; i--) {
					if (this.data[i]._not_matched_columns === undefined) {
						this.data[i]._not_matched_columns = [];
					}

					if ("CHECKBOX" === e.target.type.toUpperCase()) {
						this.data[i]._filtered = e.target.checked && !this.data[i][searchedColumn];
						continue;
					}

					if (e.target.value === ""
						|| this.data[i][searchedColumn]
						&& this.data[i][searchedColumn].toString().slice(0, e.target.value.length).toLowerCase() == e.target.value.toString().toLowerCase()) {
						var _not_matched_index = this.data[i]._not_matched_columns.indexOf(searchedColumn);
						if (_not_matched_index > -1) {
							this.data[i]._not_matched_columns.splice(_not_matched_index, 1);
						}
						if (this.data[i]._not_matched_columns.length === 0) {
							this.data[i]._filtered = false;
						} else {
							this.data[i]._filtered = true;
						}
					} else {
						this.data[i]._filtered = true;
						if (this.data[i]._not_matched_columns.indexOf(searchedColumn) === -1) {
							this.data[i]._not_matched_columns.push(searchedColumn);
						}
					}
				};

				this.currentpage = 0;
				this.refreshPagination();
			}
		},
		_sort: function(array, key, desc) {
			if (!array) return;

			return array.sort(function(a, b) {
				var x = a[key], y = b[key];

				if (typeof x === 'undefined' || typeof y === 'undefined') {
					//sort undefined after
					if (typeof x === 'undefined'){
						return !desc;
					}else{
						return desc;
					}
				} else {
					if (typeof x === "string" && typeof y === "string"){
						x = x.toLowerCase();
						y = y.toLowerCase();
					}
					if (desc){
						return ((x < y) ? 1 : ((x > y) ? -1 : 0));
					} else {
						return ((x < y) ? -1 : ((x > y) ? 1 : 0));
					}
				}
			});
		},

		//==================
		//pagination
		firstPage: function() {
			this.currentpage = 0;
		},
		prevPage: function() {
			if ( this.currentpage > 0 ) {
				this.currentpage--;
			}
		},
		nextPage: function() {
			if ( this.currentpage < this.getPageCount() ) {
				this.currentpage++;
			}
		},
		lastPage: function() {
			this.currentpage = this.getPageCount();
		},
		getItemCount: function() {
			var count = 0;
			for (var i = this.data.length - 1; i >= 0; i--) {
				if (!this.data[i]._filtered) {
					count++;
				}
			};
			return count;
		},
		getPageCount: function() {
			return Math.ceil( this.getItemCount() / this.perpage ) - 1;
		},
		setPage: function(e,d,t) {
			this.currentpage = parseInt( t.dataset.item, 10 );
		},
		currentpageChanged: function(){
			this.filterPage();
			this.currentRange = this.range();
			this.firstItemIndex = this.currentpage * this.perpage + 1;
			if (this.currentpage === this.pageCount) {
				this.lastItemIndex = this.itemCount;
			} else {
				this.lastItemIndex = (this.currentpage + 1)* this.perpage;
			}
		},
		perpageChanged: function(){
			this.currentpage = 0;
			this.refreshPagination();
		},
		range: function() {
			var paginations = [];
			var start = this.currentpage;

			if ( start > this.getPageCount() - this.rangeSize ) {
				start = this.getPageCount() - this.rangeSize + 1;
			}

			for ( var i = start; i < start + this.rangeSize; i++ ) {
				if (i >= 0) {
					paginations.push(i);
				}
			}
			return paginations;
		},
		filterPage: function() {
			var from = this.currentpage * this.perpage;
			var to   = from + this.perpage;
			var count = 0;
			for (var i = 0; i < this.data.length; i++) {
				if (!this.data[i]._filtered) {
					count++;
				}
				if (count <= from || count > to) {
					this.data[i]._hidden = true;
				} else {
					this.data[i]._hidden = false;
				}
			};
		},
		refreshPagination: function() {
			// Update current range to account for items per page, range.
			this.currentRange = this.range();

			// Cache the total page count and item count
			this.itemCount = this.getItemCount();
			this.pageCount = this.getPageCount();
			this.firstItemIndex = this.currentpage * this.perpage + 1;
			if (this.currentpage === this.pageCount) {
				this.lastItemIndex = this.itemCount;
			} else {
				this.lastItemIndex = (this.currentpage + 1)* this.perpage;
			}

			// Update model bound to UI with filtered range
			this.filterPage();
		},


		//=======================//
		//data manipulation//
		select: function(e,p){
			var row = e.target.templateInstance.model.row;
			var index = this.selected.indexOf(row);
			if (index > -1) {
				if(row._selected){
					this.selected.splice(index, 1);
					row._selected = false;
				}
			} else {
				if(!row._selected){
					this.selected.push(row);
					row._selected = true;
				}
			}
			e.preventDefault();
		},
		selectall: function(e,p){
			if(e.target.checked){
				for(var i=0;i<this.data.length;i++){
					if (!this.data[i]._filtered && !this.data[i]._hidden) {
						if(this.selected.indexOf(this.data[i])==-1) {
							this.selected.push(this.data[i]);
						}
						this.data[i]._selected = true;
					}
				}
			}else{
				this.selected = [];
				for(var i=0;i<this.data.length;i++){
					this.data[i]._selected = false;
				}
			}
		},
		create: function(obj) {
			var _new = obj instanceof Object ? obj : {};
			var _default = {_editing_column: this.meta[0].name};
			for (var i = this.meta.length - 1; i >= 0; i--) {
				if (this.meta[i].default && obj[this.meta[i].name] === undefined) {
					_new[this.meta[i].name] = this.meta[i].default;
				}
			};
			this.data.splice(0,0,_new);
			this.modified.push(_new);
		},
		copy: function(obj) {
			if (obj) {
				var _new = JSON.parse(JSON.stringify(obj));
				if (_new.id) {
					delete _new.id
				}
				if (_new._selected) {
					_new._selected = false;
				}
				_new._editing_column = this.meta[0].name;
				this.data.splice(0,0,_new);
				this.modified.push(_new);
			}
		},
		copySelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.copy(this.selected[i]);
			};
			this.clearSelected();
		},
		remove: function(obj) {
			var found_index = this.data.indexOf(obj);
			if (found_index !== -1) {
				this.data.splice(found_index,1);
				this.deleted.push(obj);
			}
		},
		removeSelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.remove(this.selected[i]);
			}
			this.clearSelected();
		},
		clearSelected: function() {
			for (var i = this.selected.length - 1; i >= 0; i--) {
				this.selected[i]._selected = false;
			}
			this.selected.length = 0;
		},
		clearModified: function() {
			this.modified.length = 0;
		},
		clearDeleted: function() {
			this.deleted.length = 0;
		}
	});
	</script>
</polymer-element>
